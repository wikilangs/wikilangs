---
import BaseLayout from '@layouts/BaseLayout.astro';
import WorldMap from '@components/WorldMap.astro';
import languages from '@data/languages.json';
import languageCountries from '@data/language_countries.json';
---

<BaseLayout
  title="Playground"
  description="Explore the linguistic universe. Generate text, discover connections, and visualize the DNA of 340+ languages."
>
  <!-- Language Selector Modal -->
  <div id="lang-modal" class="modal hidden">
    <div class="modal-backdrop"></div>
    <div class="modal-content modal-content-large">
      <div class="modal-header">
        <h2>Choose a Language</h2>
        <button class="modal-close" aria-label="Close">&times;</button>
      </div>

      <!-- View toggle -->
      <div class="view-toggle">
        <button class="view-btn active" data-view="map">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <circle cx="12" cy="12" r="10"/>
            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
          </svg>
          Map View
        </button>
        <button class="view-btn" data-view="list">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <rect x="3" y="3" width="7" height="7" rx="1"/>
            <rect x="14" y="3" width="7" height="7" rx="1"/>
            <rect x="3" y="14" width="7" height="7" rx="1"/>
            <rect x="14" y="14" width="7" height="7" rx="1"/>
          </svg>
          List View
        </button>
      </div>

      <!-- Map View -->
      <div class="modal-view map-view" id="map-view">
        <p class="map-hint">Click a country to see available languages</p>
        <div class="map-wrapper" id="world-map-container">
          <WorldMap mode="selector" />
        </div>
      </div>

      <!-- List View -->
      <div class="modal-view list-view hidden" id="list-view">
        <div class="search-box">
          <input type="text" id="lang-search" placeholder="Search by name or code..." autocomplete="off" />
        </div>
        <div class="lang-filters">
          <button class="filter-btn active" data-filter="all">All</button>
          <button class="filter-btn" data-filter="major">Major (500k+)</button>
          <button class="filter-btn" data-filter="medium">Medium</button>
          <button class="filter-btn" data-filter="emerging">Emerging</button>
        </div>
        <div class="lang-grid" id="lang-grid">
          {languages.map(lang => (
            <button class="lang-card" data-code={lang.code} data-name={lang.name.toLowerCase()} data-vocab={lang.vocabulary_size}>
              <span class="lang-code">{lang.code}</span>
              <span class="lang-name">{lang.name}</span>
              <span class="lang-vocab">{(lang.vocabulary_size / 1000).toFixed(0)}k words</span>
            </button>
          ))}
        </div>
      </div>
    </div>
  </div>

  <section class="hero-playground">
    <div class="container">
      <h1>Language Playground</h1>
      <p class="hero-subtitle">Dive into the linguistic universe. Every language tells a story.</p>

      <!-- Unified Status Bar - 3 sections, fixed layout -->
      <div class="status-bar">
        <!-- Section 1: Language Selector -->
        <button id="select-lang-btn" class="status-section status-selector">
          <div class="status-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="10"/>
              <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
            </svg>
          </div>
          <span class="status-label">Language</span>
          <svg class="status-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </button>

        <!-- Section 2: Selected Language Display -->
        <div id="lang-display" class="status-section status-display">
          <div id="lang-empty" class="lang-state lang-state-empty">
            <span class="empty-dot"></span>
            <span>No language selected</span>
          </div>
          <div id="lang-active" class="lang-state lang-state-active hidden">
            <span class="lang-badge" id="current-flag">EN</span>
            <span class="lang-name" id="current-label">English</span>
          </div>
        </div>

        <!-- Section 3: Environment Status -->
        <div id="env-status" class="status-section status-env">
          <div id="env-loading" class="env-state env-state-loading">
            <div class="env-spinner">
              <svg viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2" opacity="0.2"/>
                <path d="M12 2a10 10 0 0 1 10 10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              </svg>
            </div>
            <div class="env-info">
              <span class="env-label" id="progress-status">Setting up environment...</span>
              <div class="env-progress">
                <div class="env-progress-track">
                  <div class="env-progress-fill" id="progress-fill"></div>
                </div>
                <span class="env-pct" id="progress-pct">0%</span>
              </div>
            </div>
          </div>
          <div id="env-ready" class="env-state env-state-ready hidden">
            <div class="env-check">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
            </div>
            <span class="env-ready-label">Ready</span>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Main Playground -->
  <section class="playground-main">
    <div class="container">
      <div class="demo-grid" id="demo-grid">
        <!-- Language DNA -->
        <div class="demo-card" data-demo="dna">
          <div class="demo-icon dna-icon-wrapper">
            <svg viewBox="0 0 60 80" class="dna-card-icon">
              <!-- Left backbone -->
              <path class="dna-strand-left" d="M15,5 Q30,15 15,25 Q0,35 15,45 Q30,55 15,65 Q0,75 15,80" fill="none" stroke="currentColor" stroke-width="2.5"/>
              <!-- Right backbone -->
              <path class="dna-strand-right" d="M45,5 Q30,15 45,25 Q60,35 45,45 Q30,55 45,65 Q60,75 45,80" fill="none" stroke="currentColor" stroke-width="2.5"/>
              <!-- Base pairs -->
              <line class="dna-base" x1="15" y1="5" x2="45" y2="5" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
              <line class="dna-base" x1="15" y1="25" x2="45" y2="25" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
              <line class="dna-base" x1="15" y1="45" x2="45" y2="45" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
              <line class="dna-base" x1="15" y1="65" x2="45" y2="65" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
              <!-- Nucleotides -->
              <circle cx="15" cy="5" r="3" fill="currentColor"/>
              <circle cx="45" cy="5" r="3" fill="currentColor" opacity="0.7"/>
              <circle cx="15" cy="25" r="3" fill="currentColor"/>
              <circle cx="45" cy="25" r="3" fill="currentColor" opacity="0.7"/>
              <circle cx="15" cy="45" r="3" fill="currentColor"/>
              <circle cx="45" cy="45" r="3" fill="currentColor" opacity="0.7"/>
              <circle cx="15" cy="65" r="3" fill="currentColor"/>
              <circle cx="45" cy="65" r="3" fill="currentColor" opacity="0.7"/>
            </svg>
          </div>
          <h3>Language DNA</h3>
          <p>Discover what makes this language unique - character frequencies, word patterns, and linguistic fingerprints.</p>
          <button class="demo-btn" data-action="dna">Analyze DNA</button>
        </div>

        <!-- Word Flow -->
        <div class="demo-card" data-demo="flow">
          <div class="demo-icon flow-illustration">
            <span class="flow-node">word</span>
            <svg class="flow-arrow" viewBox="0 0 24 12" width="20" height="10">
              <path d="M0 6h18M14 2l6 4-6 4" fill="none" stroke="currentColor" stroke-width="1.5"/>
            </svg>
            <span class="flow-node seed">seed</span>
            <svg class="flow-arrow" viewBox="0 0 24 12" width="20" height="10">
              <path d="M0 6h18M14 2l6 4-6 4" fill="none" stroke="currentColor" stroke-width="1.5"/>
            </svg>
            <span class="flow-node">word</span>
          </div>
          <h3>Word Flow</h3>
          <p>Explore word sequences as a directed flow. See what comes before and after, and discover sentence paths.</p>
          <button class="demo-btn" data-action="flow">Explore Flow</button>
        </div>

        <!-- Text Weaver -->
        <div class="demo-card" data-demo="weaver">
          <div class="demo-icon weaver-illustration">
            <span class="weave-node">the</span>
            <span class="weave-arrow">→</span>
            <span class="weave-node">quick</span>
            <span class="weave-arrow">→</span>
            <span class="weave-node">fox</span>
          </div>
          <h3>Text Weaver</h3>
          <p>Watch the Markov chain weave words together, creating text that emerges from statistical patterns.</p>
          <button class="demo-btn" data-action="weaver">Start Weaving</button>
        </div>

        <!-- Zipf's Law -->
        <div class="demo-card" data-demo="zipf">
          <div class="demo-icon zipf-illustration">
            <span class="zipf-bar b1"></span>
            <span class="zipf-bar b2"></span>
            <span class="zipf-bar b3"></span>
            <span class="zipf-bar b4"></span>
            <span class="zipf-bar b5"></span>
            <span class="zipf-bar b6"></span>
            <span class="zipf-bar b7"></span>
          </div>
          <h3>Zipf's Law</h3>
          <p>Witness one of nature's most beautiful patterns - how word frequencies follow a perfect power law.</p>
          <button class="demo-btn" data-action="zipf">Reveal Pattern</button>
        </div>

        <!-- Rare Words Museum -->
        <div class="demo-card" data-demo="museum">
          <div class="demo-icon museum-illustration">
            <span class="museum-word w1">ephemeral</span>
            <span class="museum-word w2">serendipity</span>
            <span class="museum-word w3">luminescence</span>
          </div>
          <h3>Rare Words Museum</h3>
          <p>Discover the longest, rarest, and most unusual words. Every language has hidden treasures.</p>
          <button class="demo-btn" data-action="museum">Enter Museum</button>
        </div>

        <!-- Language Bridge -->
        <div class="demo-card" data-demo="bridge">
          <div class="demo-icon bridge-illustration">
            <span class="bridge-word left">hello</span>
            <span class="bridge-connector"></span>
            <span class="bridge-word right">hola</span>
          </div>
          <h3>Language Bridge</h3>
          <p>Find words that transcend borders. Discover cognates, loanwords, and universal concepts.</p>
          <button class="demo-btn" data-action="bridge">Build Bridge</button>
        </div>
      </div>

      <!-- Demo Display Area -->
      <div id="demo-display" class="demo-display hidden">
        <button class="back-btn" id="back-btn">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
            <path d="M12 4L6 10L12 16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
          Back to Playground
        </button>
        <div id="demo-content"></div>
      </div>
    </div>
  </section>
</BaseLayout>

<script is:inline define:vars={{ languagesData: languages, countryData: languageCountries }}>
// ========== STATE ==========
let pyodide = null;
let pyodideReady = false;
let currentLang = null;  // No language selected initially
let loadedModels = {};   // Track which models are loaded: { vocab: bool, markov: bool, ngram: bool }
let pendingAction = null; // Store pending demo action while selecting language

// ========== DOM ==========
const modal = document.getElementById('lang-modal');
const selectLangBtn = document.getElementById('select-lang-btn');
const langEmpty = document.getElementById('lang-empty');
const langActive = document.getElementById('lang-active');
const currentFlag = document.getElementById('current-flag');
const currentLabel = document.getElementById('current-label');
const envLoading = document.getElementById('env-loading');
const envReady = document.getElementById('env-ready');
const langSearch = document.getElementById('lang-search');
const langGrid = document.getElementById('lang-grid');
const progressStatus = document.getElementById('progress-status');
const progressPct = document.getElementById('progress-pct');
const progressFill = document.getElementById('progress-fill');
const demoGrid = document.getElementById('demo-grid');
const demoDisplay = document.getElementById('demo-display');
const demoContent = document.getElementById('demo-content');
const backBtn = document.getElementById('back-btn');

// ========== MODAL ==========
const mapView = document.getElementById('map-view');
const listView = document.getElementById('list-view');
const worldMapContainer = document.getElementById('world-map-container');

function openModal() {
  modal.classList.remove('hidden');
  document.body.style.overflow = 'hidden';
  // Focus search only in list view
  if (!listView.classList.contains('hidden')) {
    langSearch.focus();
  }
}

function closeModal() {
  modal.classList.add('hidden');
  document.body.style.overflow = '';
  langSearch.value = '';
  filterLangs('');
}

selectLangBtn.addEventListener('click', openModal);
modal.querySelector('.modal-backdrop').addEventListener('click', closeModal);
modal.querySelector('.modal-close').addEventListener('click', closeModal);

// View toggle
document.querySelectorAll('.view-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const view = btn.dataset.view;
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    if (view === 'map') {
      mapView.classList.remove('hidden');
      listView.classList.add('hidden');
    } else {
      mapView.classList.add('hidden');
      listView.classList.remove('hidden');
      langSearch.focus();
    }
  });
});

// Handle language selection from world map
worldMapContainer?.addEventListener('languageSelect', async (e) => {
  const { code, name } = e.detail;

  // If language changed, reset loaded models
  if (currentLang && currentLang.code !== code) {
    loadedModels = {};
  }

  currentLang = { code, name };
  updateLangDisplay();
  closeModal();
  await runPendingAction();
});

langSearch.addEventListener('input', e => filterLangs(e.target.value));

function filterLangs(q) {
  q = q.toLowerCase();
  langGrid.querySelectorAll('.lang-card').forEach(card => {
    const match = card.dataset.name.includes(q) || card.dataset.code.includes(q);
    card.style.display = match ? '' : 'none';
  });
}

document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const filter = btn.dataset.filter;
    langGrid.querySelectorAll('.lang-card').forEach(card => {
      const vocab = parseInt(card.dataset.vocab);
      let show = true;
      if (filter === 'major') show = vocab >= 500000;
      else if (filter === 'medium') show = vocab >= 100000 && vocab < 500000;
      else if (filter === 'emerging') show = vocab < 100000;
      card.style.display = show ? '' : 'none';
    });
  });
});

langGrid.addEventListener('click', async e => {
  const card = e.target.closest('.lang-card');
  if (!card) return;
  const newLang = { code: card.dataset.code, name: card.querySelector('.lang-name').textContent };

  // If language changed, reset loaded models
  if (currentLang && currentLang.code !== newLang.code) {
    loadedModels = {};
  }

  currentLang = newLang;
  updateLangDisplay();
  closeModal();
  await runPendingAction();
});

function updateLangDisplay() {
  if (!currentLang) return;
  // Hide empty state, show active state
  langEmpty.classList.add('hidden');
  langActive.classList.remove('hidden');
  // Update display
  currentFlag.textContent = currentLang.code.toUpperCase();
  currentLabel.textContent = currentLang.name;
}

// Run pending action after language selection
async function runPendingAction() {
  if (!pendingAction) return;
  const action = pendingAction;
  pendingAction = null;

  // Wait for pyodide to be ready
  if (!pyodideReady) {
    // Will be triggered by the pyodide ready handler
    pendingAction = action;
    return;
  }

  demoGrid.classList.add('hidden');
  demoDisplay.classList.remove('hidden');
  await runDemo(action);
}

// ========== ENV PROGRESS ==========
function showProgress(status) {
  progressStatus.textContent = status;
  progressPct.textContent = '0%';
  progressFill.style.width = '0%';
  envLoading.classList.remove('hidden');
  envReady.classList.add('hidden');
}

function updateProgress(pct, status) {
  progressFill.style.width = pct + '%';
  progressPct.textContent = Math.round(pct) + '%';
  if (status) progressStatus.textContent = status;
}

function hideProgress() {
  envLoading.classList.add('hidden');
  envReady.classList.remove('hidden');
}

function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

async function downloadWithProgress(url, label, baseProgress, progressRange) {
  const startTime = Date.now();
  let lastUpdate = 0;

  const response = await fetch(url);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);

  const contentLength = response.headers.get('content-length');
  const total = contentLength ? parseInt(contentLength) : 0;

  if (!response.body || !total) {
    // Fallback: no streaming, just show downloading
    updateProgress(baseProgress + progressRange / 2, `${label}: downloading...`);
    const data = await response.arrayBuffer();
    updateProgress(baseProgress + progressRange, `${label}: ${formatBytes(data.byteLength)}`);
    return new Uint8Array(data);
  }

  const reader = response.body.getReader();
  const chunks = [];
  let received = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    chunks.push(value);
    received += value.length;

    // Update progress (throttle to every 100ms)
    const now = Date.now();
    if (now - lastUpdate > 100) {
      lastUpdate = now;
      const pct = baseProgress + (received / total) * progressRange;
      const elapsed = (now - startTime) / 1000;
      const speed = received / elapsed;
      const remaining = (total - received) / speed;
      const eta = remaining > 0 ? `${Math.ceil(remaining)}s` : '';

      updateProgress(pct, `${label}: ${formatBytes(received)} / ${formatBytes(total)}${eta ? ' • ' + eta : ''}`);
    }
  }

  // Combine chunks
  const data = new Uint8Array(received);
  let pos = 0;
  for (const chunk of chunks) {
    data.set(chunk, pos);
    pos += chunk.length;
  }

  updateProgress(baseProgress + progressRange, `${label}: ${formatBytes(received)} ✓`);
  return data;
}

// ========== PYODIDE ==========
async function initPyodide() {
  showProgress('Initializing Python environment...');
  updateProgress(5);

  try {
    pyodide = await loadPyodide({
      indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.27.0/full/'
    });
    updateProgress(30, 'Installing pandas...');

    await pyodide.loadPackage('pandas');
    updateProgress(50, 'Installing numpy...');

    await pyodide.loadPackage('numpy');
    updateProgress(70, 'Installing parquet support...');

    await pyodide.loadPackage('micropip');
    const micropip = pyodide.pyimport('micropip');
    await micropip.install('fastparquet');
    updateProgress(90, 'Setting up environment...');

    await pyodide.runPythonAsync(PYTHON_CODE);
    updateProgress(100, 'Environment ready ✓');
    pyodideReady = true;

    setTimeout(hideProgress, 800);
  } catch (err) {
    progressStatus.textContent = 'Error: ' + err.message;
    console.error(err);
  }
}

// Load specific model types lazily
async function loadVocab() {
  if (loadedModels.vocab) return true;
  const lang = currentLang.code;
  const base = `https://huggingface.co/wikilangs/${lang}/resolve/main/models`;

  showProgress('Loading vocabulary...');
  const data = await downloadWithProgress(
    `${base}/vocabulary/${lang}_vocabulary.parquet`,
    'Vocabulary', 0, 80
  );
  updateProgress(90, 'Processing vocabulary...');
  pyodide.globals.set('_vocab_bytes', data);
  await pyodide.runPythonAsync(`process_vocab_bytes(_vocab_bytes)`);
  updateProgress(100, 'Vocabulary ready ✓');
  loadedModels.vocab = true;
  await new Promise(r => setTimeout(r, 300));
  hideProgress();
  return true;
}

async function loadMarkov() {
  if (loadedModels.markov) return true;
  const lang = currentLang.code;
  const base = `https://huggingface.co/wikilangs/${lang}/resolve/main/models`;

  showProgress('Loading Markov model...');
  const data = await downloadWithProgress(
    `${base}/word_markov/${lang}_markov_ctx2_word.parquet`,
    'Markov model', 0, 80
  );
  updateProgress(90, 'Processing Markov model...');
  pyodide.globals.set('_markov_bytes', data);
  await pyodide.runPythonAsync(`process_markov_bytes(_markov_bytes)`);
  updateProgress(100, 'Markov model ready ✓');
  loadedModels.markov = true;
  await new Promise(r => setTimeout(r, 300));
  hideProgress();
  return true;
}

async function loadNgram() {
  if (loadedModels.ngram) return true;
  const lang = currentLang.code;
  const base = `https://huggingface.co/wikilangs/${lang}/resolve/main/models`;

  showProgress('Loading n-gram model...');
  const data = await downloadWithProgress(
    `${base}/word_ngram/${lang}_3gram_word.parquet`,
    'N-gram model', 0, 80
  );
  updateProgress(90, 'Processing n-gram model...');
  pyodide.globals.set('_ngram_bytes', data);
  await pyodide.runPythonAsync(`process_ngram_bytes(_ngram_bytes)`);
  updateProgress(100, 'N-gram model ready ✓');
  loadedModels.ngram = true;
  await new Promise(r => setTimeout(r, 300));
  hideProgress();
  return true;
}

// Define which models each demo needs
const demoRequirements = {
  dna: ['vocab'],
  flow: ['ngram', 'vocab'],
  weaver: ['markov'],
  zipf: ['vocab'],
  museum: ['vocab'],
  bridge: ['vocab']
};

async function ensureModelsLoaded(action) {
  const required = demoRequirements[action] || [];
  for (const model of required) {
    if (model === 'vocab') await loadVocab();
    else if (model === 'markov') await loadMarkov();
    else if (model === 'ngram') await loadNgram();
  }
}

// ========== DEMOS ==========
document.querySelectorAll('.demo-btn').forEach(btn => {
  btn.addEventListener('click', async () => {
    const action = btn.dataset.action;

    if (!currentLang) {
      // Store the pending action and open language selector
      pendingAction = action;
      openModal();
      return;
    }
    if (!pyodideReady) {
      alert('Please wait for the environment to initialize');
      return;
    }
    demoGrid.classList.add('hidden');
    demoDisplay.classList.remove('hidden');
    await runDemo(action);
  });
});

backBtn.addEventListener('click', () => {
  demoDisplay.classList.add('hidden');
  demoGrid.classList.remove('hidden');
});

async function runDemo(action) {
  demoContent.innerHTML = '<div class="demo-loading"><div class="spinner"></div><p>Loading model data...</p></div>';

  try {
    // Load required models first
    await ensureModelsLoaded(action);

    // Then run the demo
    demoContent.innerHTML = '<div class="demo-loading"><div class="spinner"></div><p>Analyzing...</p></div>';

    switch (action) {
      case 'dna': await showDNA(); break;
      case 'flow': await showFlow(); break;
      case 'weaver': await showWeaver(); break;
      case 'zipf': await showZipf(); break;
      case 'museum': await showMuseum(); break;
      case 'bridge': await showBridge(); break;
    }
  } catch (err) {
    demoContent.innerHTML = `<p class="error">Error: ${err.message}</p>`;
    console.error(err);
  }
}

// ========== DNA DEMO ==========
async function showDNA() {
  const result = await pyodide.runPythonAsync(`
import json
json.dumps(get_dna_data())
  `);
  const data = JSON.parse(result);
  if (!data) {
    demoContent.innerHTML = '<p class="error">Could not analyze language</p>';
    return;
  }

  // Build character frequency bars SVG
  const charEntries = Object.entries(data.chars).slice(0, 20);
  const maxCharFreq = charEntries[0]?.[1] || 1;
  const charBars = charEntries.map(([char, freq], i) => {
    const width = (freq / maxCharFreq) * 300;
    const y = i * 28;
    return `
      <g transform="translate(0, ${y})">
        <text x="0" y="18" class="char-label">${char}</text>
        <rect x="30" y="4" width="${width}" height="20" rx="3" class="char-bar" style="animation-delay: ${i * 30}ms"/>
        <text x="${35 + width}" y="18" class="char-pct">${(freq * 100).toFixed(1)}%</text>
      </g>
    `;
  }).join('');

  // Build word length histogram SVG
  const lenEntries = Object.entries(data.lengths).filter(([k]) => parseInt(k) <= 15);
  const maxLenFreq = Math.max(...lenEntries.map(([,v]) => v));
  const barWidth = 35;
  const lenBars = lenEntries.map(([len, freq], i) => {
    const height = (freq / maxLenFreq) * 150;
    const x = i * barWidth;
    return `
      <g transform="translate(${x}, 0)">
        <rect x="2" y="${160 - height}" width="${barWidth - 4}" height="${height}" rx="2" class="len-bar" style="animation-delay: ${i * 50}ms"/>
        <text x="${barWidth/2}" y="175" class="len-label">${len}</text>
      </g>
    `;
  }).join('');

  // Top words cloud
  const topWords = data.top_words.slice(0, 30).map((w, i) => {
    const size = Math.max(0.7, 1.8 - i * 0.04);
    return `<span class="cloud-word" style="font-size: ${size}em; animation-delay: ${i * 40}ms">${w.word}</span>`;
  }).join(' ');

  demoContent.innerHTML = `
    <div class="dna-demo">
      <header class="demo-header">
        <h2>Language DNA</h2>
        <p class="demo-subtitle">${currentLang.name}</p>
      </header>

      <div class="stats-row">
        <div class="stat-box">
          <span class="stat-number">${data.vocab_size.toLocaleString()}</span>
          <span class="stat-label">Vocabulary</span>
        </div>
        <div class="stat-box">
          <span class="stat-number">${data.avg_len}</span>
          <span class="stat-label">Avg Length</span>
        </div>
        <div class="stat-box">
          <span class="stat-number">${data.unique_chars}</span>
          <span class="stat-label">Characters</span>
        </div>
      </div>

      <div class="dna-grid">
        <section class="dna-section">
          <h3>Character Frequency</h3>
          <p class="section-hint">Which letters dominate this language?</p>
          <svg class="char-chart" viewBox="0 0 450 ${charEntries.length * 28}" preserveAspectRatio="xMinYMin meet">
            ${charBars}
          </svg>
        </section>

        <section class="dna-section">
          <h3>Word Length Distribution</h3>
          <p class="section-hint">How long are words typically?</p>
          <svg class="len-chart" viewBox="0 0 ${lenEntries.length * barWidth} 180" preserveAspectRatio="xMinYMin meet">
            ${lenBars}
          </svg>
        </section>
      </div>

      <section class="dna-section full-width">
        <h3>Most Common Words</h3>
        <p class="section-hint">The building blocks of ${currentLang.name}</p>
        <div class="word-cloud">${topWords}</div>
      </section>

      <section class="dna-section full-width">
        <h3>Script Characters</h3>
        <p class="section-hint">All unique characters found</p>
        <div class="char-grid">
          ${data.char_list.slice(0, 60).map(c => `<span class="char-cell">${c}</span>`).join('')}
        </div>
      </section>
    </div>
  `;
}

// ========== FLOW DEMO ==========
async function showFlow() {
  // Use text_direction from language data
  const isRTL = currentLang.text_direction === 'rtl';

  // Flow visualization state
  let graphData = null;
  let nodePositions = {};
  let selectedNodes = new Set();
  let hoveredNode = null;
  let sentences = [];
  let suggestions = [];
  const width = 850, height = 420;
  const padding = { left: 60, right: 60, top: 50, bottom: 50 };

  demoContent.innerHTML = `
    <div class="flow-demo${isRTL ? ' rtl' : ''}">
      <header class="demo-header">
        <h2>Word Flow</h2>
        <p class="demo-subtitle">Explore word sequences in ${currentLang.name}</p>
      </header>

      <div class="flow-input-wrapper">
        <div class="flow-input">
          <input type="text" id="flow-word" placeholder="Enter a word to explore..." autocomplete="off" ${isRTL ? 'dir="rtl"' : ''} />
          <button id="flow-go" class="primary-btn">Explore</button>
        </div>
        <div class="flow-suggestions" id="flow-suggestions"></div>
      </div>

      <div class="flow-instructions">
        <span class="instruction-item"><span class="dot selected"></span> Click to select</span>
        <span class="instruction-item"><span class="dot"></span> Hover to preview</span>
      </div>

      <div class="flow-container" id="flow-container">
        <p class="flow-hint">Enter a word above to see its flow</p>
      </div>

      <div class="sentence-panel" id="sentence-panel">
        <div class="sentence-empty">Select words to generate sentence combinations</div>
      </div>
    </div>
  `;

  async function buildGraph(word) {
    const result = await pyodide.runPythonAsync(`
import json
json.dumps(build_word_flow_graph("${word.replace(/"/g, '\\"')}", depth=2, top_k=8))
    `);
    return JSON.parse(result);
  }

  async function findPaths(selected) {
    if (!graphData || selected.length === 0) return [];
    const selectedJson = JSON.stringify(selected);
    const graphJson = JSON.stringify(graphData);
    const result = await pyodide.runPythonAsync(`
import json
_graph = json.loads('''${graphJson.replace(/'/g, "\\'")}''')
_selected = json.loads('${selectedJson}')
json.dumps(find_flow_paths(_graph, _selected, max_paths=8))
    `);
    return JSON.parse(result);
  }

  async function getSuggestions(prefix) {
    const result = await pyodide.runPythonAsync(`
import json
json.dumps(get_word_suggestions("${prefix.replace(/"/g, '\\"')}", limit=8))
    `);
    return JSON.parse(result);
  }

  function calculateLayout(data, visibleNodeIds) {
    if (!data || !data.columns) return {};
    const positions = {};
    const columns = data.columns;
    let columnKeys = Object.keys(columns).map(Number).sort((a, b) => a - b);

    // Reverse for RTL languages (flow goes right to left)
    if (isRTL) {
      columnKeys = columnKeys.reverse();
    }

    const numColumns = columnKeys.length;
    if (numColumns === 0) return {};

    const usableWidth = width - padding.left - padding.right;
    const usableHeight = height - padding.top - padding.bottom;
    const columnWidth = usableWidth / numColumns;

    columnKeys.forEach((colIndex, colPosition) => {
      // Only include nodes that are in the visible set
      const nodeIds = columns[colIndex].filter(id => visibleNodeIds.has(id));
      const numNodes = Math.min(nodeIds.length, 8);
      if (numNodes === 0) return;

      const nodeSpacing = usableHeight / (numNodes + 1);
      const x = padding.left + columnWidth * colPosition + columnWidth / 2;

      nodeIds.slice(0, 8).forEach((nodeId, nodeIndex) => {
        const y = padding.top + nodeSpacing * (nodeIndex + 1);
        positions[nodeId] = { x, y };
      });
    });

    return positions;
  }

  function getVisibleEdges() {
    if (!graphData) return [];
    const edges = graphData.edges;

    // Count edges per source node for crowd management
    const edgesBySource = {};
    edges.forEach(e => {
      if (!edgesBySource[e.from_id]) edgesBySource[e.from_id] = [];
      edgesBySource[e.from_id].push(e);
    });

    // Sort edges by probability and take top 4 per source (crowd management)
    const visibleEdges = [];
    Object.values(edgesBySource).forEach(sourceEdges => {
      sourceEdges.sort((a, b) => b.probability - a.probability);
      visibleEdges.push(...sourceEdges.slice(0, 4));
    });

    return visibleEdges;
  }

  // Get the set of node IDs that should be visible (have at least one visible edge)
  function getVisibleNodeIds(visibleEdges) {
    const ids = new Set();
    visibleEdges.forEach(e => {
      ids.add(e.from_id);
      ids.add(e.to_id);
    });
    // Always include seed node
    if (graphData) {
      graphData.nodes.forEach(n => { if (n.is_seed) ids.add(n.id); });
    }
    return ids;
  }

  // Separate function for updating visual state without recreating SVG
  function updateVisuals() {
    if (!graphData || typeof d3 === 'undefined') return;

    const svg = d3.select('#flow-container svg');
    if (svg.empty()) return;

    const visibleEdges = getVisibleEdges();

    // Update edges
    svg.select('.edges-layer').selectAll('path')
      .data(visibleEdges, e => `${e.from_id}-${e.to_id}`)
      .attr('stroke', e => {
        const isHighlighted = hoveredNode && (e.from_id === hoveredNode || e.to_id === hoveredNode);
        const isSelected = selectedNodes.has(e.from_id) && selectedNodes.has(e.to_id);
        if (isSelected) return 'var(--color-accent)';
        if (isHighlighted) return 'var(--color-accent)';
        return 'var(--color-text-muted)';
      })
      .attr('stroke-opacity', e => {
        const isHighlighted = hoveredNode && (e.from_id === hoveredNode || e.to_id === hoveredNode);
        const isSelected = selectedNodes.has(e.from_id) && selectedNodes.has(e.to_id);
        if (isSelected) return 0.9;
        if (isHighlighted) return 0.7;
        return 0.15 + e.probability * 0.35;
      })
      .attr('stroke-width', e => {
        const isHighlighted = hoveredNode && (e.from_id === hoveredNode || e.to_id === hoveredNode);
        const isSelected = selectedNodes.has(e.from_id) && selectedNodes.has(e.to_id);
        if (isSelected) return 3;
        if (isHighlighted) return 2.5;
        return 1 + e.probability * 1.5;
      })
      .attr('stroke-dasharray', e => {
        const isHighlighted = hoveredNode && (e.from_id === hoveredNode || e.to_id === hoveredNode);
        return isHighlighted ? '6 3' : 'none';
      });

    // Update nodes
    svg.select('.nodes-layer').selectAll('g.node')
      .attr('class', d => {
        let cls = 'node';
        if (d.is_seed) cls += ' seed';
        if (selectedNodes.has(d.id)) cls += ' selected';
        if (hoveredNode === d.id) cls += ' hovered';
        return cls;
      })
      .attr('filter', d => selectedNodes.has(d.id) || d.is_seed ? 'url(#glow)' : null)
      .each(function(d) {
        const g = d3.select(this);
        g.select('rect')
          .attr('fill', () => {
            if (d.is_seed) return 'var(--color-accent)';
            if (selectedNodes.has(d.id)) return 'var(--color-accent-dark)';
            return 'var(--color-surface)';
          })
          .attr('stroke', () => {
            if (d.is_seed || selectedNodes.has(d.id)) return 'var(--color-accent)';
            if (hoveredNode === d.id) return 'var(--color-accent)';
            return 'var(--color-border)';
          })
          .attr('stroke-width', () => {
            if (d.is_seed || selectedNodes.has(d.id) || hoveredNode === d.id) return 2;
            return 1;
          });
        g.select('text')
          .attr('fill', () => {
            if (d.is_seed || selectedNodes.has(d.id)) return 'white';
            return 'var(--color-text)';
          });
      });
  }

  function render() {
    const container = document.getElementById('flow-container');
    if (!container || !graphData) return;

    // Check if D3 is loaded
    if (typeof d3 === 'undefined') {
      container.innerHTML = '<p class="error">Loading visualization library...</p>';
      setTimeout(render, 100);
      return;
    }

    // Clear and create SVG
    container.innerHTML = '';
    const svg = d3.select(container)
      .append('svg')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('class', 'flow-svg');

    // Add defs for glow filter
    const defs = svg.append('defs');

    // Glow filter for selected nodes
    const filter = defs.append('filter')
      .attr('id', 'glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    filter.append('feGaussianBlur')
      .attr('stdDeviation', '4')
      .attr('result', 'coloredBlur');
    const feMerge = filter.append('feMerge');
    feMerge.append('feMergeNode').attr('in', 'coloredBlur');
    feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

    // Background
    svg.append('rect')
      .attr('width', width)
      .attr('height', height)
      .attr('fill', 'var(--color-bg)')
      .attr('rx', 12);

    // Get visible edges
    const visibleEdges = getVisibleEdges();

    // Edge layer
    const edgeGroup = svg.append('g').attr('class', 'edges-layer');

    // Create link generator
    const linkGen = d3.linkHorizontal()
      .x(d => d.x)
      .y(d => d.y);

    // Draw edges
    edgeGroup.selectAll('path')
      .data(visibleEdges, e => `${e.from_id}-${e.to_id}`)
      .join('path')
      .attr('d', e => {
        const from = nodePositions[e.from_id];
        const to = nodePositions[e.to_id];
        if (!from || !to) return '';
        return linkGen({ source: from, target: to });
      })
      .attr('fill', 'none')
      .attr('stroke', 'var(--color-text-muted)')
      .attr('stroke-opacity', e => 0.15 + e.probability * 0.35)
      .attr('stroke-width', e => 1 + e.probability * 1.5);

    // Node layer
    const nodeGroup = svg.append('g').attr('class', 'nodes-layer');

    // Only show nodes that have positions (calculated only for visible nodes)
    const nodesData = graphData.nodes.filter(n => nodePositions[n.id]);

    // Draw nodes
    const nodeWidth = 72, nodeHeight = 28, nodeRadius = 6;

    const nodeElements = nodeGroup.selectAll('g.node')
      .data(nodesData, d => d.id)
      .join('g')
      .attr('class', d => {
        let cls = 'node';
        if (d.is_seed) cls += ' seed';
        if (selectedNodes.has(d.id)) cls += ' selected';
        return cls;
      })
      .attr('transform', d => {
        const pos = nodePositions[d.id];
        return `translate(${pos.x}, ${pos.y})`;
      })
      .style('cursor', 'pointer')
      .attr('filter', d => selectedNodes.has(d.id) || d.is_seed ? 'url(#glow)' : null);

    // Node rectangles
    nodeElements.append('rect')
      .attr('x', -nodeWidth / 2)
      .attr('y', -nodeHeight / 2)
      .attr('width', nodeWidth)
      .attr('height', nodeHeight)
      .attr('rx', nodeRadius)
      .attr('fill', d => {
        if (d.is_seed) return 'var(--color-accent)';
        if (selectedNodes.has(d.id)) return 'var(--color-accent-dark)';
        return 'var(--color-surface)';
      })
      .attr('stroke', d => {
        if (d.is_seed || selectedNodes.has(d.id)) return 'var(--color-accent)';
        return 'var(--color-border)';
      })
      .attr('stroke-width', d => {
        if (d.is_seed || selectedNodes.has(d.id)) return 2;
        return 1;
      });

    // Node text
    nodeElements.append('text')
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', d => {
        if (d.is_seed || selectedNodes.has(d.id)) return 'white';
        return 'var(--color-text)';
      })
      .attr('font-size', '11px')
      .attr('font-weight', d => d.is_seed ? '600' : '500')
      .style('pointer-events', 'none')
      .style('user-select', 'none')
      .text(d => d.word.length > 8 ? d.word.slice(0, 7) + '…' : d.word);

    // Add interactions - using function references to avoid recreation issues
    nodeElements.on('click', handleNodeClick);
    nodeElements.on('mouseenter', handleNodeEnter);
    nodeElements.on('mouseleave', handleNodeLeave);

    // Column labels
    let columnKeys = Object.keys(graphData.columns).map(Number).sort((a, b) => a - b);
    if (isRTL) columnKeys = columnKeys.reverse();

    const usableWidth = width - padding.left - padding.right;
    const colWidth = usableWidth / columnKeys.length;

    svg.append('g').attr('class', 'column-labels')
      .selectAll('text')
      .data(columnKeys)
      .join('text')
      .attr('x', (col, i) => padding.left + colWidth * i + colWidth / 2)
      .attr('y', 25)
      .attr('text-anchor', 'middle')
      .attr('fill', col => col === 0 ? 'var(--color-accent)' : 'var(--color-text-muted)')
      .attr('font-size', '10px')
      .attr('font-weight', col => col === 0 ? '600' : '400')
      .text(col => {
        if (col === 0) return isRTL ? 'הזרע' : 'seed';
        if (isRTL) {
          // For RTL: negative columns are "after", positive are "before"
          if (col < 0) return `+${Math.abs(col)}`;
          if (col > 0) return `−${col}`;
        } else {
          if (col < 0) return `−${Math.abs(col)}`;
          if (col > 0) return `+${col}`;
        }
        return '';
      });
  }

  async function handleNodeClick(event, d) {
    event.stopPropagation();
    if (d.is_seed) return; // Can't deselect seed

    if (selectedNodes.has(d.id)) {
      selectedNodes.delete(d.id);
    } else {
      selectedNodes.add(d.id);
    }
    updateVisuals();
    await updateSentences();
  }

  function handleNodeEnter(event, d) {
    hoveredNode = d.id;
    updateVisuals();
  }

  function handleNodeLeave() {
    hoveredNode = null;
    updateVisuals();
  }

  async function updateSentences() {
    const panel = document.getElementById('sentence-panel');
    if (!panel) return;

    const selected = Array.from(selectedNodes);
    if (selected.length === 0) {
      panel.innerHTML = '<div class="sentence-empty">Select words to generate sentence combinations</div>';
      return;
    }

    panel.innerHTML = '<div class="sentence-loading"><div class="spinner small"></div></div>';

    try {
      sentences = await findPaths(selected);

      if (sentences.length === 0) {
        panel.innerHTML = '<div class="sentence-empty">No valid paths found through selected words</div>';
        return;
      }

      panel.innerHTML = `
        <h4>Possible Sequences <span class="sentence-hint">(sorted by perplexity, lower is better)</span></h4>
        <div class="sentence-list">
          ${sentences.slice(0, 8).map((s, i) => {
            return `
              <div class="sentence-item" ${isRTL ? 'dir="rtl"' : ''}>
                <span class="sentence-rank">${i + 1}</span>
                <span class="sentence-text">${s.words.join(' ')}</span>
                <span class="sentence-perplexity" title="Perplexity">⟂ ${s.perplexity}</span>
              </div>
            `;
          }).join('')}
        </div>
      `;
    } catch (e) {
      console.error('Path finding error:', e);
      panel.innerHTML = '<div class="sentence-empty">Could not find paths</div>';
    }
  }

  function showSuggestions(items) {
    const suggestionsEl = document.getElementById('flow-suggestions');
    if (!suggestionsEl) return;

    if (!items || items.length === 0) {
      suggestionsEl.innerHTML = '';
      suggestionsEl.classList.remove('visible');
      return;
    }

    suggestionsEl.innerHTML = items.map(s =>
      `<button class="suggestion-item" data-word="${s.word}">${s.word}</button>`
    ).join('');
    suggestionsEl.classList.add('visible');

    // Add click handlers
    suggestionsEl.querySelectorAll('.suggestion-item').forEach(btn => {
      btn.addEventListener('click', async () => {
        const word = btn.dataset.word;
        document.getElementById('flow-word').value = word;
        suggestionsEl.classList.remove('visible');
        await initFlow(word);
      });
    });
  }

  async function initFlow(word) {
    const container = document.getElementById('flow-container');
    container.innerHTML = '<div class="demo-loading"><div class="spinner"></div></div>';
    selectedNodes.clear();
    document.getElementById('flow-suggestions').classList.remove('visible');

    try {
      graphData = await buildGraph(word);

      if (!graphData.nodes || graphData.nodes.length === 0) {
        container.innerHTML = `<p class="no-results">No connections found for "${word}". Try a more common word.</p>`;
        return;
      }

      // Auto-select seed node
      const seedNode = graphData.nodes.find(n => n.is_seed);
      if (seedNode) {
        selectedNodes.add(seedNode.id);
      }

      // Calculate visible edges and nodes BEFORE layout
      const visibleEdges = getVisibleEdges();
      const visibleNodeIds = getVisibleNodeIds(visibleEdges);
      nodePositions = calculateLayout(graphData, visibleNodeIds);
      render();
      await updateSentences();
    } catch (e) {
      console.error('Graph build error:', e);
      container.innerHTML = `<p class="error">Error building graph: ${e.message}</p>`;
    }
  }

  // Load initial suggestions
  async function loadInitialSuggestions() {
    try {
      suggestions = await getSuggestions('');
      if (suggestions.length > 0) {
        showSuggestions(suggestions.slice(0, 8));
      }
    } catch (e) {
      console.error('Failed to load suggestions:', e);
    }
  }

  // Event listeners
  document.getElementById('flow-go').addEventListener('click', async () => {
    const word = document.getElementById('flow-word').value.trim();
    if (!word) return;
    await initFlow(word);
  });

  const flowInput = document.getElementById('flow-word');
  flowInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
      const word = e.target.value.trim();
      if (word) await initFlow(word);
    }
  });

  // Autocomplete on input
  let debounceTimer;
  flowInput.addEventListener('input', async (e) => {
    const prefix = e.target.value.trim();
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async () => {
      try {
        const results = await getSuggestions(prefix);
        showSuggestions(results);
      } catch (err) {
        console.error('Suggestion error:', err);
      }
    }, 150);
  });

  flowInput.addEventListener('focus', () => {
    if (suggestions.length > 0) {
      showSuggestions(suggestions.slice(0, 8));
    }
  });

  // Hide suggestions when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.flow-input-wrapper')) {
      document.getElementById('flow-suggestions')?.classList.remove('visible');
    }
  });

  // Load initial suggestions
  loadInitialSuggestions();
}

// ========== WEAVER DEMO ==========
async function showWeaver() {
  demoContent.innerHTML = `
    <div class="weaver-demo">
      <header class="demo-header">
        <h2>Text Weaver</h2>
        <p class="demo-subtitle">Markov chain text generation for ${currentLang.name}</p>
      </header>

      <div class="weaver-controls">
        <div class="control-row">
          <label>Seed words (optional)</label>
          <input type="text" id="weaver-seed" placeholder="Start with these words..." />
        </div>
        <div class="control-row">
          <label>Length: <span id="len-val">60</span> words</label>
          <input type="range" id="weaver-len" min="20" max="150" value="60" />
        </div>
        <button id="weave-go" class="primary-btn">Weave Text</button>
      </div>

      <div class="weaver-output" id="weaver-output">
        <p class="output-hint">Click "Weave Text" to generate</p>
      </div>
    </div>
  `;

  const lenSlider = document.getElementById('weaver-len');
  const lenVal = document.getElementById('len-val');
  lenSlider.addEventListener('input', () => lenVal.textContent = lenSlider.value);

  document.getElementById('weave-go').addEventListener('click', async () => {
    const seed = document.getElementById('weaver-seed').value;
    const len = document.getElementById('weaver-len').value;
    const output = document.getElementById('weaver-output');

    output.innerHTML = '<div class="generating"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>';

    const seedArg = seed ? `"${seed.replace(/"/g, '\\"')}"` : 'None';
    const result = await pyodide.runPythonAsync(`generate_text(${len}, ${seedArg})`);

    // Typewriter effect
    output.innerHTML = '';
    const words = result.split(' ');
    for (let i = 0; i < words.length; i++) {
      const span = document.createElement('span');
      span.className = 'typed-word';
      span.textContent = words[i] + ' ';
      span.style.animationDelay = `${i * 25}ms`;
      output.appendChild(span);
    }
  });
}

// ========== ZIPF DEMO ==========
async function showZipf() {
  const result = await pyodide.runPythonAsync(`
import json
json.dumps(get_zipf_data())
  `);
  const data = JSON.parse(result);

  if (!data || !data.length) {
    demoContent.innerHTML = '<p class="error">Could not load frequency data</p>';
    return;
  }

  // SVG chart
  const width = 700, height = 400;
  const margin = { top: 30, right: 30, bottom: 50, left: 70 };
  const chartW = width - margin.left - margin.right;
  const chartH = height - margin.top - margin.bottom;

  const maxRank = 500;
  const maxFreq = data[0].frequency;
  const minFreq = data[Math.min(maxRank, data.length) - 1].frequency;

  // Log scales
  const xScale = r => margin.left + (Math.log10(r) / Math.log10(maxRank)) * chartW;
  const yScale = f => margin.top + chartH - (Math.log10(f) / Math.log10(maxFreq)) * chartH;

  // Path
  let path = `M ${xScale(1)} ${yScale(data[0].frequency)}`;
  for (let i = 1; i < Math.min(maxRank, data.length); i++) {
    path += ` L ${xScale(i + 1)} ${yScale(data[i].frequency)}`;
  }

  // Highlighted points
  const highlights = [0, 4, 9, 49, 99, 199, 499].filter(i => i < data.length);
  const points = highlights.map(i => `
    <circle cx="${xScale(i + 1)}" cy="${yScale(data[i].frequency)}" r="5" fill="var(--color-accent)"/>
    <text x="${xScale(i + 1)}" y="${yScale(data[i].frequency) - 10}" text-anchor="middle" font-size="10" fill="var(--color-text-secondary)">${data[i].word}</text>
  `).join('');

  // Top words table
  const topTable = data.slice(0, 10).map((d, i) => `
    <div class="zipf-row">
      <span class="zipf-rank">#${i + 1}</span>
      <span class="zipf-word">${d.word}</span>
      <span class="zipf-freq">${d.frequency.toLocaleString()}</span>
    </div>
  `).join('');

  demoContent.innerHTML = `
    <div class="zipf-demo">
      <header class="demo-header">
        <h2>Zipf's Law</h2>
        <p class="demo-subtitle">${currentLang.name} word frequency distribution</p>
      </header>

      <div class="zipf-chart-container">
        <svg viewBox="0 0 ${width} ${height}" class="zipf-chart">
          <!-- Grid -->
          <g class="grid">
            ${[1, 10, 100].map(r => `<line x1="${xScale(r)}" y1="${margin.top}" x2="${xScale(r)}" y2="${height - margin.bottom}" stroke="var(--color-border)" stroke-dasharray="3,3"/>`).join('')}
          </g>

          <!-- Axes -->
          <line x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" stroke="var(--color-text)"/>
          <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" stroke="var(--color-text)"/>

          <!-- Labels -->
          <text x="${width / 2}" y="${height - 10}" text-anchor="middle" fill="var(--color-text-secondary)" font-size="12">Word Rank (log scale)</text>
          <text x="15" y="${height / 2}" text-anchor="middle" fill="var(--color-text-secondary)" font-size="12" transform="rotate(-90, 15, ${height / 2})">Frequency (log)</text>

          <!-- Axis ticks -->
          ${[1, 10, 100, 500].map(r => `<text x="${xScale(r)}" y="${height - margin.bottom + 20}" text-anchor="middle" font-size="10" fill="var(--color-text-secondary)">${r}</text>`).join('')}

          <!-- Data line -->
          <path d="${path}" fill="none" stroke="var(--color-accent)" stroke-width="2" class="zipf-line"/>

          <!-- Points -->
          ${points}
        </svg>
      </div>

      <div class="zipf-insight">
        <h3>The Pattern</h3>
        <p>The most common word appears <strong>${Math.round(data[0].frequency / data[1].frequency)}×</strong> more than #2,
        and <strong>${Math.round(data[0].frequency / data[9].frequency)}×</strong> more than #10.
        This power law appears in every human language.</p>
      </div>

      <div class="zipf-table">
        <h3>Top 10 Words</h3>
        ${topTable}
      </div>
    </div>
  `;
}

// ========== MUSEUM DEMO ==========
async function showMuseum() {
  const result = await pyodide.runPythonAsync(`
import json
json.dumps(get_rare_words())
  `);
  const data = JSON.parse(result);

  if (!data) {
    demoContent.innerHTML = '<p class="error">Could not load vocabulary</p>';
    return;
  }

  const longestCards = data.longest.slice(0, 8).map(w => `
    <div class="exhibit-card gold">
      <span class="exhibit-word">${w.word}</span>
      <span class="exhibit-meta">${w.length} characters</span>
    </div>
  `).join('');

  const unusualCards = data.unusual.slice(0, 12).map(w => `
    <div class="exhibit-card purple">
      <span class="exhibit-word">${w.word}</span>
      <span class="exhibit-meta">${w.freq.toLocaleString()} uses</span>
    </div>
  `).join('');

  const rareCards = data.rarest.slice(0, 10).map(w => `
    <div class="exhibit-card red">
      <span class="exhibit-word">${w.word}</span>
      <span class="exhibit-meta">${w.freq} sighting${w.freq > 1 ? 's' : ''}</span>
    </div>
  `).join('');

  demoContent.innerHTML = `
    <div class="museum-demo">
      <header class="demo-header">
        <h2>Rare Words Museum</h2>
        <p class="demo-subtitle">Hidden treasures of ${currentLang.name}</p>
      </header>

      <section class="exhibit-section">
        <div class="exhibit-header">
          <span class="exhibit-icon">🏆</span>
          <div>
            <h3>Hall of Giants</h3>
            <p>The longest words in the vocabulary</p>
          </div>
        </div>
        <div class="exhibit-grid">${longestCards}</div>
      </section>

      <section class="exhibit-section">
        <div class="exhibit-header">
          <span class="exhibit-icon">✨</span>
          <div>
            <h3>Cabinet of Curiosities</h3>
            <p>Words with unusual characters</p>
          </div>
        </div>
        <div class="exhibit-grid">${unusualCards}</div>
      </section>

      <section class="exhibit-section">
        <div class="exhibit-header">
          <span class="exhibit-icon">🔮</span>
          <div>
            <h3>Endangered Collection</h3>
            <p>Rarely seen words</p>
          </div>
        </div>
        <div class="exhibit-grid">${rareCards}</div>
      </section>
    </div>
  `;
}

// ========== BRIDGE DEMO ==========
async function showBridge() {
  const otherLangs = languagesData.filter(l => l.code !== currentLang.code);

  demoContent.innerHTML = `
    <div class="bridge-demo">
      <header class="demo-header">
        <h2>Language Bridge</h2>
        <p class="demo-subtitle">Find shared words between languages</p>
      </header>

      <div class="bridge-selector">
        <div class="bridge-lang">
          <span class="bridge-code">${currentLang.code.toUpperCase()}</span>
          <span>${currentLang.name}</span>
        </div>
        <span class="bridge-arrow">⟷</span>
        <select id="bridge-target">
          ${otherLangs.map(l => `<option value="${l.code}">${l.name}</option>`).join('')}
        </select>
        <button id="bridge-go" class="primary-btn">Find Connections</button>
      </div>

      <div class="bridge-results" id="bridge-results">
        <p class="bridge-hint">Select a language and click "Find Connections"</p>
      </div>
    </div>
  `;

  document.getElementById('bridge-go').addEventListener('click', async () => {
    const target = document.getElementById('bridge-target').value;
    const results = document.getElementById('bridge-results');

    results.innerHTML = '<div class="demo-loading"><div class="spinner"></div><p>Building bridge...</p></div>';

    // Fetch target vocab
    const targetWords = await pyodide.runPythonAsync(`
import json
await fetch_target_vocab('${target}')
    `);

    // Find shared
    const shared = await pyodide.runPythonAsync(`
import json
json.dumps(find_shared())
    `);

    const sharedWords = JSON.parse(shared);
    const targetName = otherLangs.find(l => l.code === target)?.name || target;

    if (!sharedWords.length) {
      results.innerHTML = '<p class="no-results">No obvious shared words found.</p>';
      return;
    }

    results.innerHTML = `
      <div class="shared-header">
        <h3>${sharedWords.length} Shared Words</h3>
        <p>Words appearing in both ${currentLang.name} and ${targetName}</p>
      </div>
      <div class="shared-grid">
        ${sharedWords.map(w => `
          <div class="shared-card">
            <span class="shared-word">${w.word}</span>
            <span class="shared-freq">${w.frequency.toLocaleString()}</span>
          </div>
        `).join('')}
      </div>
    `;
  });
}

// ========== PYTHON CODE ==========
const PYTHON_CODE = `
import pandas as pd
import numpy as np
import json
import random
from collections import defaultdict
from pyodide.http import pyfetch

class Store:
    vocab_df = None
    vocab_idx = {}
    markov_idx = {}
    ngram_idx = {}
    target_words = set()

store = Store()

def bytes_to_df(data):
    """Convert JS Uint8Array to pandas DataFrame"""
    import io
    # Convert JS typed array to Python bytes
    raw = bytes(data.to_py())
    return pd.read_parquet(io.BytesIO(raw))

def process_vocab_bytes(data):
    """Process vocabulary parquet from JS bytes"""
    df = bytes_to_df(data)
    store.vocab_df = df
    # Vectorized: build index using zip on columns (much faster than iterrows)
    tokens = df['token'].tolist()
    freqs = df['frequency'].tolist()
    idfs = df['idf_score'].tolist()
    ranks = df['rank'].tolist()
    store.vocab_idx = {t: {'freq': int(f), 'idf': float(i), 'rank': int(r)}
                       for t, f, i, r in zip(tokens, freqs, idfs, ranks)}
    return True

def process_markov_bytes(data):
    """Process Markov model parquet from JS bytes"""
    df = bytes_to_df(data)
    store.markov_idx = defaultdict(list)
    # Use itertuples (10x faster than iterrows)
    for row in df.itertuples(index=False):
        ctx = row.context
        if isinstance(ctx, str):
            ctx = tuple(json.loads(ctx))
        else:
            ctx = tuple(ctx)
        store.markov_idx[ctx].append((row.next_token, float(row.probability)))
    return True

def process_ngram_bytes(data):
    """Process n-gram model parquet from JS bytes"""
    df = bytes_to_df(data)
    store.ngram_idx = defaultdict(list)
    # Use itertuples (10x faster than iterrows)
    for row in df.itertuples(index=False):
        ng = row.ngram
        if isinstance(ng, str):
            ng = json.loads(ng)
        else:
            ng = list(ng)
        if len(ng) >= 2:
            store.ngram_idx[tuple(ng[:-1])].append((ng[-1], int(row.frequency)))
    return True

# Legacy async functions (kept for bridge demo)
async def fetch_parquet(url):
    try:
        resp = await pyfetch(url)
        if resp.status != 200:
            return None
        data = await resp.bytes()
        with open('/tmp/data.parquet', 'wb') as f:
            f.write(data)
        return pd.read_parquet('/tmp/data.parquet')
    except Exception as e:
        print(f"Fetch error: {e}")
        return None

def get_dna_data():
    if store.vocab_df is None:
        return None
    df = store.vocab_df
    tokens = df['token'].tolist()
    freqs = df['frequency'].tolist()

    # Char freq
    char_freq = defaultdict(int)
    for t, f in zip(tokens[:8000], freqs[:8000]):
        for c in str(t).lower():
            if c.isalpha():
                char_freq[c] += f
    total = sum(char_freq.values())
    chars = {k: v/total for k, v in sorted(char_freq.items(), key=lambda x: -x[1])[:30]}

    # Length dist
    len_freq = defaultdict(int)
    for t, f in zip(tokens[:8000], freqs[:8000]):
        len_freq[len(str(t))] += f
    total_len = sum(len_freq.values())
    lengths = {str(k): v/total_len for k, v in sorted(len_freq.items()) if k <= 20}

    # Top words
    top_words = [{'word': t, 'freq': f} for t, f in zip(tokens[:50], freqs[:50])]

    # Unique chars
    all_chars = set()
    for t in tokens[:3000]:
        all_chars.update(str(t))
    char_list = sorted(all_chars)

    # Avg length
    avg_len = sum(len(str(t)) * f for t, f in zip(tokens[:8000], freqs[:8000])) / sum(freqs[:8000])

    return {
        'chars': chars,
        'lengths': lengths,
        'top_words': top_words,
        'char_list': char_list[:100],
        'vocab_size': len(df),
        'avg_len': round(avg_len, 2),
        'unique_chars': len(char_list)
    }

def get_zipf_data():
    if store.vocab_df is None:
        return None
    df = store.vocab_df.head(500)
    return [{'rank': i+1, 'frequency': int(row['frequency']), 'word': row['token']} for i, (_, row) in enumerate(df.iterrows())]

def get_rare_words():
    if store.vocab_df is None:
        return None
    df = store.vocab_df
    tokens = df['token'].tolist()
    freqs = df['frequency'].tolist()

    # Longest
    with_len = [(t, len(str(t)), f) for t, f in zip(tokens, freqs) if f > 3]
    longest = sorted(with_len, key=lambda x: -x[1])[:20]

    # Unusual chars
    common = set('abcdefghijklmnopqrstuvwxyz0123456789')
    unusual = []
    for t, f in zip(tokens[:4000], freqs[:4000]):
        if any(c.lower() not in common for c in str(t)) and f > 5:
            unusual.append((t, f))
    unusual = unusual[:30]

    # Rarest
    rarest = [(t, f) for t, f in zip(tokens[-80:], freqs[-80:]) if len(str(t)) > 3][:20]

    return {
        'longest': [{'word': t, 'length': l, 'freq': f} for t, l, f in longest],
        'unusual': [{'word': t, 'freq': f} for t, f in unusual],
        'rarest': [{'word': t, 'freq': f} for t, f in rarest]
    }

def generate_text(length=50, seed=None):
    if not store.markov_idx:
        return "Model not loaded"
    if seed:
        toks = seed.strip().split()
        ctx = tuple(toks[-2:]) if len(toks) >= 2 else tuple(toks)
    else:
        ctx = random.choice(list(store.markov_idx.keys()))
    result = list(ctx)
    for _ in range(length):
        trans = store.markov_idx.get(ctx, [])
        if not trans:
            ctx = random.choice(list(store.markov_idx.keys()))
            trans = store.markov_idx.get(ctx, [])
            if not trans:
                break
        toks, probs = zip(*trans)
        total = sum(probs)
        probs = [p/total for p in probs]
        nxt = random.choices(toks, weights=probs)[0]
        result.append(nxt)
        ctx = (ctx[-1], nxt) if len(ctx) >= 2 else (nxt,)
    cleaned = [t[1:] if t.startswith('▁') else t for t in result]
    return ' '.join(cleaned)

def get_word_neighbors(word, limit=20):
    if not store.ngram_idx:
        return []
    neighbors = defaultdict(int)
    for ctx, trans in store.ngram_idx.items():
        if word in ctx:
            for nxt, freq in trans:
                if nxt != word:
                    neighbors[nxt] += freq
        for nxt, freq in trans:
            if nxt == word:
                for c in ctx:
                    if c != word:
                        neighbors[c] += freq
    return [{'word': w, 'strength': s} for w, s in sorted(neighbors.items(), key=lambda x: -x[1])[:limit]]

def is_valid_word(w):
    """Check if a token is a valid word (not just numbers/punctuation)."""
    if not w or not isinstance(w, str):
        return False
    # Must have at least one letter
    return any(c.isalpha() for c in w)

def build_word_flow_graph(seed_word, depth=2, top_k=8):
    """Build a directed graph for Word Flow visualization."""
    if not store.ngram_idx:
        return {'nodes': [], 'edges': [], 'columns': {}}

    nodes = {}  # id -> node data
    edges_set = set()  # (from_id, to_id) to avoid duplicates
    edges = []  # list of edge data
    columns = defaultdict(list)

    # Add seed word at column 0
    seed_id = f"0:{seed_word}"
    nodes[seed_id] = {
        'id': seed_id,
        'word': seed_word,
        'column': 0,
        'frequency': 0,
        'is_seed': True
    }
    columns[0].append(seed_id)

    # Track which words are at which column for proper edge creation
    word_at_col = {(0, seed_word): seed_id}

    def add_edge(from_id, to_id, freq):
        """Add edge only if both nodes exist and edge doesn't exist."""
        if from_id in nodes and to_id in nodes:
            edge_key = (from_id, to_id)
            if edge_key not in edges_set:
                edges_set.add(edge_key)
                edges.append({
                    'from_id': from_id,
                    'to_id': to_id,
                    'frequency': freq,
                    'probability': 0
                })

    def get_predecessors(word):
        """Find words that come immediately before this word."""
        preds = defaultdict(int)
        for ctx, trans in store.ngram_idx.items():
            # ctx is (w1, w2), trans is [(w3, freq), ...]
            # If word is w3 (result), w2 is predecessor
            for nxt, freq in trans:
                if nxt == word and len(ctx) >= 1:
                    prev = ctx[-1]
                    if is_valid_word(prev) and prev != word:
                        preds[prev] += freq
            # If word is w2 (last context), w1 is predecessor
            if len(ctx) >= 2 and ctx[-1] == word:
                prev = ctx[-2] if len(ctx) > 1 else ctx[0]
                if is_valid_word(prev) and prev != word:
                    preds[prev] += sum(f for _, f in trans)
        return preds

    def get_successors(word):
        """Find words that come immediately after this word."""
        succs = defaultdict(int)
        for ctx, trans in store.ngram_idx.items():
            # If word is in context, look at what follows
            if word in ctx:
                for nxt, freq in trans:
                    if is_valid_word(nxt) and nxt != word:
                        succs[nxt] += freq
        return succs

    # Build predecessors (left side, negative columns)
    def build_predecessors(word, col, remaining, k):
        if remaining <= 0:
            return
        preds = get_predecessors(word)
        top_preds = sorted(preds.items(), key=lambda x: -x[1])[:k]

        target_key = (col + 1, word)
        target_id = word_at_col.get(target_key)

        for pred_word, freq in top_preds:
            node_id = f"{col}:{pred_word}"
            node_key = (col, pred_word)

            if node_key not in word_at_col:
                nodes[node_id] = {
                    'id': node_id,
                    'word': pred_word,
                    'column': col,
                    'frequency': freq,
                    'is_seed': False
                }
                columns[col].append(node_id)
                word_at_col[node_key] = node_id

            # Add edge from predecessor to current word
            if target_id:
                add_edge(word_at_col[node_key], target_id, freq)

            # Recurse
            build_predecessors(pred_word, col - 1, remaining - 1, max(4, k // 2))

    # Build successors (right side, positive columns)
    def build_successors(word, col, remaining, k):
        if remaining <= 0:
            return
        succs = get_successors(word)
        top_succs = sorted(succs.items(), key=lambda x: -x[1])[:k]

        source_key = (col - 1, word)
        source_id = word_at_col.get(source_key)

        for succ_word, freq in top_succs:
            node_id = f"{col}:{succ_word}"
            node_key = (col, succ_word)

            if node_key not in word_at_col:
                nodes[node_id] = {
                    'id': node_id,
                    'word': succ_word,
                    'column': col,
                    'frequency': freq,
                    'is_seed': False
                }
                columns[col].append(node_id)
                word_at_col[node_key] = node_id

            # Add edge from current word to successor
            if source_id:
                add_edge(source_id, word_at_col[node_key], freq)

            # Recurse
            build_successors(succ_word, col + 1, remaining - 1, max(4, k // 2))

    # Build graph in both directions from seed
    build_predecessors(seed_word, -1, depth, top_k)
    build_successors(seed_word, 1, depth, top_k)

    # Remove nodes without any edges (disconnected)
    connected_nodes = set()
    for e in edges:
        connected_nodes.add(e['from_id'])
        connected_nodes.add(e['to_id'])
    connected_nodes.add(seed_id)  # Always keep seed

    # Filter nodes and columns to only connected ones
    nodes = {k: v for k, v in nodes.items() if k in connected_nodes}
    for col in columns:
        columns[col] = [nid for nid in columns[col] if nid in connected_nodes]

    # Normalize edge probabilities per source node
    source_totals = defaultdict(int)
    for e in edges:
        source_totals[e['from_id']] += e['frequency']
    for e in edges:
        total = source_totals[e['from_id']]
        e['probability'] = e['frequency'] / total if total > 0 else 0

    # Sort columns by frequency (seed first)
    for col in columns:
        columns[col] = sorted(columns[col],
            key=lambda x: -nodes[x]['frequency'] if not nodes[x]['is_seed'] else float('inf'))

    return {
        'nodes': list(nodes.values()),
        'edges': edges,
        'columns': {k: v for k, v in sorted(columns.items())}
    }

def find_flow_paths(graph_data, selected_ids, max_paths=10):
    """Find valid paths through the graph that include all selected nodes."""
    import math

    if not selected_ids or not graph_data.get('nodes'):
        return []

    nodes_map = {n['id']: n for n in graph_data['nodes']}
    adj = defaultdict(list)
    edge_probs = {}

    for e in graph_data['edges']:
        adj[e['from_id']].append(e['to_id'])
        edge_probs[(e['from_id'], e['to_id'])] = e['probability']

    selected_set = set(selected_ids)

    # Get column range
    all_cols = sorted(int(k) for k in graph_data['columns'].keys())
    if not all_cols:
        return []

    start_col = all_cols[0]
    end_col = all_cols[-1]

    paths = []
    max_search = max_paths * 10  # Search limit

    def dfs(current_id, path, visited_selected, log_prob, visited):
        if len(paths) >= max_search:
            return

        if current_id not in nodes_map:
            return

        current_col = nodes_map[current_id]['column']

        # Check if current node is selected
        new_visited = visited_selected | ({current_id} if current_id in selected_set else set())

        # If we've reached the end column
        if current_col == end_col:
            if new_visited >= selected_set:  # All selected nodes visited
                prob = math.exp(log_prob) if log_prob > -30 else 0
                # Calculate perplexity: exp(-log_prob / n)
                n = len(path)
                perplexity = math.exp(-log_prob / n) if n > 0 and log_prob < 0 else float('inf')
                paths.append({
                    'path': list(path),
                    'words': [nodes_map[nid]['word'] for nid in path],
                    'probability': prob,
                    'perplexity': round(perplexity, 2)
                })
            return

        # Continue forward
        for next_id in adj.get(current_id, []):
            if next_id in visited:  # Avoid cycles
                continue
            edge_prob = edge_probs.get((current_id, next_id), 0.001)
            new_log_prob = log_prob + math.log(max(edge_prob, 0.0001))
            dfs(next_id, path + [next_id], new_visited, new_log_prob, visited | {next_id})

    # Start from all leftmost column nodes
    start_nodes = graph_data['columns'].get(str(start_col), graph_data['columns'].get(start_col, []))
    for start_id in start_nodes[:8]:
        if start_id in nodes_map:
            dfs(start_id, [start_id], set(), 0.0, {start_id})

    # Sort by perplexity (lower is better)
    paths.sort(key=lambda x: x['perplexity'])
    return paths[:max_paths]

def get_word_suggestions(prefix='', limit=20):
    """Get word suggestions from vocabulary."""
    if store.vocab_df is None:
        return []

    tokens = store.vocab_df['token'].tolist()
    freqs = store.vocab_df['frequency'].tolist()

    suggestions = []
    prefix_lower = prefix.lower().strip()

    for t, f in zip(tokens[:5000], freqs[:5000]):
        word = str(t)
        # Filter: must be valid word, match prefix if given
        if is_valid_word(word):
            if not prefix_lower or word.lower().startswith(prefix_lower):
                suggestions.append({'word': word, 'freq': f})
                if len(suggestions) >= limit:
                    break

    return suggestions

async def fetch_target_vocab(lang):
    url = f"https://huggingface.co/wikilangs/{lang}/resolve/main/models/vocabulary/{lang}_vocabulary.parquet"
    df = await fetch_parquet(url)
    if df is None:
        store.target_words = set()
        return False
    store.target_words = set(w.lower() for w in df['token'].head(4000).tolist())
    return True

def find_shared():
    if not store.vocab_idx or not store.target_words:
        return []
    shared = []
    for word, data in store.vocab_idx.items():
        if word.lower() in store.target_words and len(word) > 3:
            shared.append({'word': word, 'frequency': data['freq']})
    return sorted(shared, key=lambda x: -x['frequency'])[:50]
`;

// ========== URL PARAMS ==========
function getQueryParams() {
  const params = new URLSearchParams(window.location.search);
  return {
    lang: params.get('lang'),
    demo: params.get('demo')
  };
}

async function handleDeepLink() {
  const { lang, demo } = getQueryParams();

  if (lang) {
    // Find the language in our data
    const langData = languagesData.find(l => l.code === lang);
    if (langData) {
      currentLang = { code: langData.code, name: langData.name };
      loadedModels = {};
      updateLangDisplay();

      // If a specific demo was requested, wait for Pyodide and launch it
      if (demo && ['dna', 'flow', 'weaver', 'zipf', 'museum', 'bridge'].includes(demo)) {
        // Wait for Pyodide to be ready
        const waitForPyodide = () => {
          if (pyodideReady) {
            demoGrid.classList.add('hidden');
            demoDisplay.classList.remove('hidden');
            runDemo(demo);
          } else {
            setTimeout(waitForPyodide, 100);
          }
        };
        waitForPyodide();
      }
    }
  }
}

// ========== CLEANUP (Memory Management) ==========
function unloadModels() {
  if (!pyodide || !pyodideReady) return;

  try {
    // Clear Python store data
    pyodide.runPython(`
if 'store' in dir():
    store.vocab_df = None
    store.vocab_idx = {}
    store.markov_idx = {}
    store.ngram_idx = {}
    store.target_words = set()
    `);

    // Reset JS tracking
    loadedModels = {};
    console.log('Models unloaded to free memory');
  } catch (e) {
    console.warn('Error unloading models:', e);
  }
}

// Unload models when navigating away
window.addEventListener('beforeunload', unloadModels);

// Also unload when page becomes hidden (tab switch, minimize)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    unloadModels();
  }
});

// ========== INIT ==========
// Load D3.js for Word Flow visualization
const d3Script = document.createElement('script');
d3Script.src = 'https://cdn.jsdelivr.net/npm/d3@7';
document.head.appendChild(d3Script);

const script = document.createElement('script');
script.src = 'https://cdn.jsdelivr.net/pyodide/v0.27.0/full/pyodide.js';
script.onload = () => {
  initPyodide();
  handleDeepLink();
};
document.head.appendChild(script);
</script>

<style is:global>
/* ========== MODAL ========== */
.modal { position: fixed; inset: 0; z-index: 100; display: flex; align-items: center; justify-content: center; }
.modal.hidden { display: none; }
.modal-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); }
.modal-content { position: relative; background: var(--color-surface); border-radius: 16px; padding: 24px; max-width: 900px; width: 90%; max-height: 85vh; overflow-y: auto; }
.modal-content-large { max-width: 1100px; }
.modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
.modal-header h2 { margin: 0; font-size: 1.5rem; }
.modal-close { background: none; border: none; font-size: 2rem; color: var(--color-text-secondary); cursor: pointer; line-height: 1; }

/* View Toggle */
.view-toggle { display: flex; gap: 8px; margin-bottom: 16px; padding: 4px; background: var(--color-bg); border-radius: 10px; width: fit-content; }
.view-btn { display: flex; align-items: center; gap: 6px; padding: 8px 16px; background: transparent; border: none; border-radius: 8px; color: var(--color-text-muted); cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s; }
.view-btn:hover { color: var(--color-text); }
.view-btn.active { background: var(--color-surface); color: var(--color-accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
.view-btn svg { flex-shrink: 0; }

/* Modal Views */
.modal-view { transition: opacity 0.2s; }
.modal-view.hidden { display: none; }

/* Map View */
.map-view { }
.map-hint { text-align: center; color: var(--color-text-muted); font-size: 0.875rem; margin-bottom: 12px; }
.map-wrapper { border-radius: 12px; overflow: hidden; }
.map-legend { display: flex; justify-content: center; gap: 24px; margin-top: 16px; flex-wrap: wrap; }
.legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; color: var(--color-text-secondary); }
.legend-swatch { width: 24px; height: 16px; border-radius: 3px; border: 1px solid var(--color-border); }
.legend-swatch.endemic { background: hsl(262, 70%, 65%); }
.legend-swatch.macro { background: repeating-linear-gradient(45deg, hsl(262, 75%, 50%), hsl(262, 75%, 50%) 2px, transparent 2px, transparent 4px); }
.legend-swatch.mixed { background: hsl(262, 70%, 65%); background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(99, 102, 241, 0.5) 2px, rgba(99, 102, 241, 0.5) 4px); }

/* List View */
.list-view { }
.search-box input { width: 100%; padding: 12px 16px; font-size: 1rem; border: 2px solid var(--color-border); border-radius: 8px; background: var(--color-bg); color: var(--color-text); }
.search-box input:focus { outline: none; border-color: var(--color-accent); }
.lang-filters { display: flex; gap: 8px; margin: 16px 0; flex-wrap: wrap; }
.filter-btn { padding: 8px 16px; border: 1px solid var(--color-border); border-radius: 20px; background: transparent; color: var(--color-text-secondary); cursor: pointer; font-size: 0.875rem; }
.filter-btn.active { background: var(--color-accent); color: white; border-color: var(--color-accent); }
.lang-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto; }
.lang-card { display: flex; flex-direction: column; align-items: flex-start; padding: 12px 16px; background: var(--color-bg); border: 1px solid var(--color-border); border-radius: 8px; cursor: pointer; text-align: left; transition: all 0.2s; }
.lang-card:hover { border-color: var(--color-accent); transform: translateY(-2px); }
.lang-code { font-size: 0.7rem; font-weight: 700; color: var(--color-accent); text-transform: uppercase; }
.lang-name { font-weight: 600; color: var(--color-text); }
.lang-vocab { font-size: 0.75rem; color: var(--color-text-muted); }

/* ========== HERO ========== */
.hero-playground { padding: 28px 0 20px; background: linear-gradient(135deg, var(--color-surface) 0%, var(--color-bg) 100%); border-bottom: 1px solid var(--color-border); text-align: center; }
.hero-playground h1 { font-size: 1.75rem; margin-bottom: 6px; background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.hero-subtitle { font-size: 1rem; color: var(--color-text-secondary); margin-bottom: 16px; }

/* ========== STATUS BAR ========== */
.status-bar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: 1px;
  max-width: 700px;
  margin: 0 auto;
  background: var(--color-border);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0,0,0,0.08);
}

.status-section {
  background: var(--color-surface);
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  min-height: 52px;
}

/* Section 1: Language Selector Button */
.status-selector {
  cursor: pointer;
  border: none;
  font: inherit;
  transition: background 0.2s;
}
.status-selector:hover {
  background: var(--color-bg);
}
.status-selector .status-icon {
  width: 24px;
  height: 24px;
  color: var(--color-accent);
  flex-shrink: 0;
}
.status-selector .status-label {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--color-text);
}
.status-selector .status-chevron {
  width: 16px;
  height: 16px;
  color: var(--color-text-muted);
  transition: transform 0.2s;
}
.status-selector:hover .status-chevron {
  transform: translateY(2px);
  color: var(--color-accent);
}

/* Section 2: Language Display */
.status-display {
  justify-content: center;
  min-width: 180px;
}
.lang-state { display: flex; align-items: center; gap: 10px; }
.lang-state.hidden { display: none; }

.lang-state-empty {
  color: var(--color-text-muted);
  font-size: 0.875rem;
}
.lang-state-empty .empty-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--color-border);
  animation: empty-pulse 2s ease-in-out infinite;
}
@keyframes empty-pulse {
  0%, 100% { opacity: 0.5; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.2); }
}

.lang-state-active .lang-badge {
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-dark));
  color: white;
  padding: 4px 10px;
  border-radius: 6px;
  font-weight: 700;
  font-size: 0.8rem;
  font-family: var(--font-mono);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.lang-state-active .lang-name {
  font-weight: 600;
  color: var(--color-text);
  font-size: 0.95rem;
}

/* Section 3: Environment Status */
.status-env {
  min-width: 200px;
}
.env-state { display: flex; align-items: center; gap: 10px; width: 100%; }
.env-state.hidden { display: none; }

/* Loading state */
.env-state-loading .env-spinner {
  width: 20px;
  height: 20px;
  color: var(--color-accent);
  flex-shrink: 0;
}
.env-state-loading .env-spinner svg {
  width: 100%;
  height: 100%;
  animation: spinner-rotate 1s linear infinite;
}
@keyframes spinner-rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
.env-state-loading .env-info {
  flex: 1;
  min-width: 0;
}
.env-state-loading .env-label {
  display: block;
  font-size: 0.75rem;
  color: var(--color-text-muted);
  margin-bottom: 6px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.env-progress {
  display: flex;
  align-items: center;
  gap: 8px;
}
.env-progress-track {
  flex: 1;
  height: 6px;
  background: var(--color-border);
  border-radius: 3px;
  overflow: hidden;
}
.env-progress-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-dark));
  border-radius: 3px;
  transition: width 0.3s ease;
  position: relative;
}
.env-progress-fill::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
  animation: shimmer 1.5s infinite;
}
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
.env-pct {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--color-accent);
  font-family: var(--font-mono);
  min-width: 32px;
  text-align: right;
}

/* Ready state */
.env-state-ready {
  justify-content: center;
}
.env-state-ready .env-check {
  width: 22px;
  height: 22px;
  background: linear-gradient(135deg, #10b981, #059669);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  animation: check-pop 0.3s ease-out;
}
.env-state-ready .env-check svg {
  width: 14px;
  height: 14px;
}
@keyframes check-pop {
  0% { transform: scale(0); }
  70% { transform: scale(1.2); }
  100% { transform: scale(1); }
}
.env-state-ready .env-ready-label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #10b981;
}

/* Responsive */
@media (max-width: 640px) {
  .status-bar {
    grid-template-columns: 1fr;
    max-width: 100%;
  }
  .status-section {
    justify-content: center;
  }
  .status-display {
    border-top: 1px solid var(--color-border);
    border-bottom: 1px solid var(--color-border);
  }
}

/* ========== LOADING OVERLAY ========== */
.loading-overlay { position: fixed; inset: 0; z-index: 200; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; }
.loading-overlay.hidden { display: none; }
.loading-card { background: var(--color-surface); border-radius: 16px; padding: 40px; text-align: center; max-width: 400px; width: 90%; }
.loading-card h3 { margin: 24px 0 8px; font-size: 1.25rem; }
.loading-card p { color: var(--color-text-secondary); margin-bottom: 24px; }
.progress-container { height: 8px; background: var(--color-border); border-radius: 4px; overflow: hidden; }
.progress-bar { height: 100%; background: linear-gradient(90deg, var(--color-accent), var(--color-accent-dark)); border-radius: 4px; transition: width 0.3s; width: 0%; }
.progress-text { display: block; margin-top: 12px; font-size: 0.875rem; color: var(--color-text-secondary); }

/* DNA Helix Spinner */
.dna-helix-spinner {
  width: 80px;
  height: 100px;
  margin: 0 auto;
  perspective: 200px;
}
.helix-svg {
  width: 100%;
  height: 100%;
  animation: dna-rotate 2.5s linear infinite;
  transform-style: preserve-3d;
}
.helix-backbone {
  fill: none;
  stroke-width: 3;
  stroke-linecap: round;
}
.helix-backbone.left { stroke: var(--color-accent); }
.helix-backbone.right { stroke: var(--color-accent-dark, #6366f1); }
.base-pair {
  stroke: var(--color-text-muted, #888);
  stroke-width: 2;
  stroke-dasharray: 3 2;
  opacity: 0.6;
}
.nucleotide {
  fill: var(--color-accent);
}
.nucleotide:nth-child(even) { fill: var(--color-accent-dark, #6366f1); }
/* Staggered pulse for nucleotides */
.n1, .n2 { animation: nuc-pulse 2.5s ease-in-out infinite 0s; }
.n3, .n4 { animation: nuc-pulse 2.5s ease-in-out infinite 0.2s; }
.n5, .n6 { animation: nuc-pulse 2.5s ease-in-out infinite 0.4s; }
.n7, .n8 { animation: nuc-pulse 2.5s ease-in-out infinite 0.6s; }
.n9, .n10 { animation: nuc-pulse 2.5s ease-in-out infinite 0.8s; }
.n11, .n12 { animation: nuc-pulse 2.5s ease-in-out infinite 1s; }
@keyframes dna-rotate {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(360deg); }
}
@keyframes nuc-pulse {
  0%, 100% { r: 4; opacity: 1; }
  50% { r: 5; opacity: 0.8; }
}

/* ========== DEMO GRID ========== */
.playground-main { padding: 48px 0; }
.demo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; }
.demo-grid.hidden { display: none; }
.demo-card { background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 16px; padding: 32px; transition: all 0.3s; }
.demo-card:hover { transform: translateY(-4px); box-shadow: 0 12px 40px rgba(0,0,0,0.15); border-color: var(--color-accent); }
.demo-icon { width: 60px; height: 60px; margin-bottom: 20px; color: var(--color-accent); }
.demo-icon svg { width: 100%; height: 100%; }
.demo-card h3 { font-size: 1.25rem; margin-bottom: 8px; }
.demo-card p { color: var(--color-text-secondary); font-size: 0.9rem; line-height: 1.6; margin-bottom: 20px; }
.demo-btn { width: 100%; padding: 12px; background: var(--color-accent); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
.demo-btn:hover { opacity: 0.9; }

/* DNA Card Icon - Rotating Double Helix */
.dna-icon-wrapper {
  perspective: 150px;
}
.dna-card-icon {
  animation: dna-spin 4s linear infinite;
  transform-style: preserve-3d;
}
@keyframes dna-spin {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(360deg); }
}

/* Word Flow Illustration */
.flow-illustration {
  display: flex;
  align-items: center;
  gap: 4px;
}
.flow-node {
  font-size: 0.6rem;
  padding: 3px 6px;
  background: rgba(var(--color-accent-rgb, 139, 92, 246), 0.1);
  border: 1px solid var(--color-border);
  border-radius: 4px;
  color: var(--color-text-secondary);
}
.flow-node.seed {
  background: var(--color-accent);
  border-color: var(--color-accent);
  color: white;
  font-weight: 600;
}
.flow-arrow {
  color: var(--color-accent);
  opacity: 0.6;
}

/* Text Weaver Illustration */
.weaver-illustration {
  display: flex;
  align-items: center;
  gap: 4px;
}
.weave-node {
  font-size: 0.6rem;
  padding: 3px 6px;
  background: rgba(var(--color-accent-rgb, 139, 92, 246), 0.15);
  border: 1px solid var(--color-accent);
  border-radius: 3px;
  color: var(--color-accent);
}
.weave-arrow {
  color: var(--color-accent);
  font-size: 0.7rem;
  opacity: 0.6;
}

/* Zipf's Law Illustration */
.zipf-illustration {
  display: flex;
  align-items: flex-end;
  gap: 3px;
  height: 45px;
}
.zipf-bar {
  width: 6px;
  background: var(--color-accent);
  border-radius: 2px 2px 0 0;
}
.zipf-bar.b1 { height: 100%; }
.zipf-bar.b2 { height: 60%; opacity: 0.9; }
.zipf-bar.b3 { height: 40%; opacity: 0.8; }
.zipf-bar.b4 { height: 28%; opacity: 0.7; }
.zipf-bar.b5 { height: 20%; opacity: 0.6; }
.zipf-bar.b6 { height: 15%; opacity: 0.5; }
.zipf-bar.b7 { height: 12%; opacity: 0.4; }

/* Rare Words Museum Illustration */
.museum-illustration {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.museum-word {
  font-size: 0.65rem;
  font-style: italic;
  color: var(--color-text-secondary);
  letter-spacing: 0.3px;
}
.museum-word.w1 { color: var(--color-accent); font-weight: 600; font-size: 0.7rem; }
.museum-word.w2 { opacity: 0.7; font-size: 0.6rem; }
.museum-word.w3 { opacity: 0.5; font-size: 0.55rem; }

/* Language Bridge Illustration */
.bridge-illustration {
  display: flex;
  align-items: center;
  gap: 6px;
}
.bridge-word {
  font-size: 0.7rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 4px;
  background: rgba(var(--color-accent-rgb, 139, 92, 246), 0.15);
  border: 1px solid var(--color-accent);
  color: var(--color-accent);
}
.bridge-connector {
  width: 16px;
  height: 2px;
  background: var(--color-accent);
  position: relative;
}
.bridge-connector::before,
.bridge-connector::after {
  content: '';
  position: absolute;
  width: 4px;
  height: 4px;
  background: var(--color-accent);
  border-radius: 50%;
  top: 50%;
  transform: translateY(-50%);
}
.bridge-connector::before { left: -2px; }
.bridge-connector::after { right: -2px; }

/* ========== DEMO DISPLAY ========== */
.demo-display { background: var(--color-surface); border-radius: 16px; padding: 32px; border: 1px solid var(--color-border); }
.demo-display.hidden { display: none; }
.back-btn { display: flex; align-items: center; gap: 8px; background: none; border: none; color: var(--color-accent); font-size: 1rem; cursor: pointer; margin-bottom: 24px; padding: 0; }
.back-btn:hover { text-decoration: underline; }
.demo-loading { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px; color: var(--color-text-secondary); }
.spinner { width: 40px; height: 40px; border: 3px solid var(--color-border); border-top-color: var(--color-accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 16px; }
@keyframes spin { to { transform: rotate(360deg); } }

/* ========== DEMO HEADER ========== */
.demo-header { margin-bottom: 32px; }
.demo-header h2 { font-size: 2rem; margin-bottom: 4px; }
.demo-subtitle { color: var(--color-text-secondary); font-size: 1.1rem; }

/* ========== STATS ROW ========== */
.stats-row { display: flex; gap: 16px; margin-bottom: 32px; flex-wrap: wrap; }
.stat-box { background: var(--color-bg); padding: 20px 28px; border-radius: 12px; text-align: center; flex: 1; min-width: 140px; }
.stat-number { display: block; font-size: 2rem; font-weight: 700; color: var(--color-accent); }
.stat-label { font-size: 0.875rem; color: var(--color-text-secondary); }

/* ========== DNA DEMO ========== */
.dna-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 32px; margin-bottom: 32px; }
.dna-section { background: var(--color-bg); border-radius: 12px; padding: 24px; }
.dna-section.full-width { grid-column: 1 / -1; }
.dna-section h3 { font-size: 1.1rem; margin-bottom: 4px; }
.section-hint { color: var(--color-text-muted); font-size: 0.875rem; margin-bottom: 16px; }
.char-chart { width: 100%; height: auto; }
.char-chart .char-label { font-family: var(--font-mono); font-size: 14px; fill: var(--color-text); }
.char-chart .char-bar { fill: var(--color-accent); animation: bar-grow 0.5s ease-out forwards; transform-origin: left; }
.char-chart .char-pct { font-size: 11px; fill: var(--color-text-secondary); }
@keyframes bar-grow { from { transform: scaleX(0); } to { transform: scaleX(1); } }
.len-chart { width: 100%; height: auto; }
.len-chart .len-bar { fill: var(--color-accent); animation: bar-rise 0.5s ease-out forwards; transform-origin: bottom; }
.len-chart .len-label { font-size: 10px; fill: var(--color-text-secondary); text-anchor: middle; }
@keyframes bar-rise { from { transform: scaleY(0); } to { transform: scaleY(1); } }
.word-cloud { line-height: 2.2; }
.cloud-word { display: inline-block; padding: 4px 10px; margin: 4px; background: var(--color-surface); border-radius: 4px; color: var(--color-accent-dark); animation: fade-in 0.3s ease-out forwards; opacity: 0; }
@keyframes fade-in { to { opacity: 1; } }
.char-grid { display: flex; flex-wrap: wrap; gap: 6px; }
.char-cell { padding: 8px 12px; background: var(--color-surface); border-radius: 4px; font-family: var(--font-mono); font-size: 1rem; }

/* ========== FLOW DEMO ========== */
.flow-demo { }
.flow-demo.rtl { direction: rtl; }
.flow-input-wrapper { position: relative; margin-bottom: 16px; }
.flow-input { display: flex; gap: 12px; }
.flow-input input { flex: 1; padding: 12px 16px; border: 2px solid var(--color-border); border-radius: 8px; background: var(--color-bg); color: var(--color-text); font-size: 1rem; }
.flow-input input:focus { outline: none; border-color: var(--color-accent); }

/* Suggestions dropdown */
.flow-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 80px;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  margin-top: 4px;
  padding: 8px;
  display: none;
  flex-wrap: wrap;
  gap: 8px;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
.flow-suggestions.visible { display: flex; }
.suggestion-item {
  padding: 6px 12px;
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: 16px;
  color: var(--color-text);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s ease;
}
.suggestion-item:hover {
  background: var(--color-accent);
  color: white;
  border-color: var(--color-accent);
}
.primary-btn { padding: 12px 24px; background: var(--color-accent); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap; }
.primary-btn:hover { opacity: 0.9; }
.flow-instructions {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin-bottom: 16px;
  font-size: 0.8rem;
  color: var(--color-text-muted);
}
.instruction-item {
  display: flex;
  align-items: center;
  gap: 6px;
}
.instruction-item .dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 2px solid var(--color-accent);
  background: var(--color-surface);
}
.instruction-item .dot.selected {
  background: var(--color-accent);
  border-color: var(--color-accent);
}
.flow-container {
  background: var(--color-bg);
  border-radius: 12px;
  min-height: 420px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  border: 1px solid var(--color-border);
}
.flow-hint { color: var(--color-text-muted); }
.flow-svg { width: 100%; height: auto; }

/* Flow nodes - smooth transitions, no scale on hover */
.flow-svg .node rect { transition: fill 0.15s ease, stroke 0.15s ease, stroke-width 0.15s ease; }
.flow-svg .node text { transition: fill 0.15s ease; }
.flow-svg .node.selected rect { filter: drop-shadow(0 0 8px var(--color-accent)); }
.flow-svg .node.seed rect { filter: drop-shadow(0 0 6px var(--color-accent)); }
.flow-svg .edges-layer path { transition: stroke 0.15s ease, stroke-opacity 0.15s ease, stroke-width 0.15s ease; }

/* Sentence Panel */
.sentence-panel {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: 12px;
  padding: 16px 20px;
  margin-top: 16px;
  min-height: 80px;
}
.sentence-panel h4 {
  font-size: 0.875rem;
  color: var(--color-text-secondary);
  margin: 0 0 12px 0;
  font-weight: 500;
}
.sentence-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-muted);
  font-size: 0.9rem;
  min-height: 48px;
}
.sentence-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 48px;
}
.spinner.small {
  width: 24px;
  height: 24px;
  border-width: 2px;
}
.sentence-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.sentence-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  background: var(--color-bg);
  border-radius: 8px;
  transition: background 0.15s ease;
}
.sentence-item:hover {
  background: var(--color-surface-alt);
}
.sentence-rank {
  width: 22px;
  height: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-accent);
  color: white;
  border-radius: 50%;
  font-size: 0.7rem;
  font-weight: 600;
  flex-shrink: 0;
}
.sentence-text {
  flex: 1;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  color: var(--color-text);
  word-break: break-word;
}
.sentence-prob {
  font-size: 0.75rem;
  color: var(--color-text-muted);
  font-family: var(--font-mono);
  flex-shrink: 0;
}
.sentence-perplexity {
  font-size: 0.75rem;
  color: var(--color-accent);
  font-family: var(--font-mono);
  flex-shrink: 0;
  background: var(--color-accent-light);
  padding: 2px 8px;
  border-radius: 10px;
}
.sentence-hint {
  font-weight: 400;
  font-size: 0.75rem;
  color: var(--color-text-muted);
  margin-left: 8px;
}

/* ========== WEAVER DEMO ========== */
.weaver-controls { display: flex; flex-direction: column; gap: 16px; margin-bottom: 24px; max-width: 500px; }
.control-row { display: flex; flex-direction: column; gap: 8px; }
.control-row label { font-size: 0.9rem; color: var(--color-text-secondary); }
.control-row input[type="text"] { padding: 12px 16px; border: 2px solid var(--color-border); border-radius: 8px; background: var(--color-bg); color: var(--color-text); font-size: 1rem; }
.control-row input[type="range"] { width: 100%; }
.weaver-output { background: var(--color-bg); border-radius: 12px; padding: 24px; min-height: 150px; line-height: 1.8; font-size: 1.1rem; }
.output-hint { color: var(--color-text-muted); margin: 0; }
.generating { display: flex; gap: 4px; }
.generating .dot { width: 8px; height: 8px; background: var(--color-accent); border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; }
.generating .dot:nth-child(1) { animation-delay: -0.32s; }
.generating .dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
.typed-word { display: inline; animation: type-in 0.2s ease-out forwards; opacity: 0; }
@keyframes type-in { to { opacity: 1; } }

/* ========== ZIPF DEMO ========== */
.zipf-chart-container { background: var(--color-bg); border-radius: 12px; padding: 20px; margin-bottom: 24px; }
.zipf-chart { width: 100%; height: auto; }
.zipf-line { animation: draw-line 1.5s ease-out forwards; stroke-dasharray: 2000; stroke-dashoffset: 2000; }
@keyframes draw-line { to { stroke-dashoffset: 0; } }
.zipf-insight { background: var(--color-accent-light); padding: 20px; border-radius: 12px; margin-bottom: 24px; }
.zipf-insight h3 { color: var(--color-accent-dark); margin-bottom: 8px; }
.zipf-insight p { color: var(--color-accent-dark); margin: 0; }
.zipf-table h3 { margin-bottom: 12px; }
.zipf-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 16px; background: var(--color-bg); border-radius: 8px; margin-bottom: 8px; }
.zipf-rank { color: var(--color-text-muted); font-size: 0.875rem; width: 40px; }
.zipf-word { flex: 1; font-weight: 600; }
.zipf-freq { color: var(--color-accent); font-size: 0.9rem; }

/* ========== MUSEUM DEMO ========== */
.exhibit-section { margin-bottom: 40px; }
.exhibit-header { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
.exhibit-icon { font-size: 2rem; }
.exhibit-header h3 { margin: 0; }
.exhibit-header p { margin: 0; color: var(--color-text-secondary); font-size: 0.9rem; }
.exhibit-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }
.exhibit-card { background: var(--color-bg); border-radius: 10px; padding: 16px; border-left: 4px solid; transition: transform 0.2s; }
.exhibit-card:hover { transform: translateY(-2px); }
.exhibit-card.gold { border-color: #f59e0b; }
.exhibit-card.purple { border-color: #8b5cf6; }
.exhibit-card.red { border-color: #ef4444; }
.exhibit-word { display: block; font-family: var(--font-mono); font-size: 0.9rem; word-break: break-all; margin-bottom: 8px; }
.exhibit-meta { font-size: 0.75rem; color: var(--color-text-muted); }

/* ========== BRIDGE DEMO ========== */
.bridge-selector { display: flex; align-items: center; gap: 16px; margin-bottom: 24px; flex-wrap: wrap; }
.bridge-lang { display: flex; align-items: center; gap: 8px; background: var(--color-bg); padding: 10px 16px; border-radius: 8px; }
.bridge-code { background: var(--color-accent); color: white; padding: 4px 8px; border-radius: 4px; font-weight: 700; font-size: 0.8rem; }
.bridge-arrow { color: var(--color-accent); font-size: 1.5rem; }
.bridge-selector select { padding: 10px 16px; border: 2px solid var(--color-border); border-radius: 8px; background: var(--color-bg); color: var(--color-text); font-size: 1rem; }
.bridge-results { background: var(--color-bg); border-radius: 12px; padding: 24px; min-height: 200px; }
.bridge-hint { color: var(--color-text-muted); text-align: center; margin: 60px 0; }
.shared-header { margin-bottom: 20px; }
.shared-header h3 { margin-bottom: 4px; }
.shared-header p { color: var(--color-text-secondary); margin: 0; }
.shared-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
.shared-card { background: var(--color-surface); padding: 12px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
.shared-word { font-weight: 600; }
.shared-freq { font-size: 0.8rem; color: var(--color-text-muted); }

/* ========== UTILITIES ========== */
.error { color: var(--color-error); text-align: center; padding: 40px; }
.no-results { color: var(--color-text-muted); text-align: center; padding: 40px; }

/* ========== RESPONSIVE ========== */
@media (max-width: 768px) {
  .hero-playground h1 { font-size: 2rem; }
  .demo-grid { grid-template-columns: 1fr; }
  .dna-grid { grid-template-columns: 1fr; }
  .stats-row { flex-direction: column; }
  .bridge-selector { flex-direction: column; align-items: stretch; }
  .flow-input { flex-direction: column; }
}
</style>
